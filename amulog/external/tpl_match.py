#!/usr/bin/env python
# coding: utf-8

"""Matching raw log messages and its templates
that is generated by external tools."""

import re
from collections import defaultdict

REPLACER = re.compile(r"\\\*[A-Z]*?\\\*") # shortest match


def generate_regex(tpl):
    d_name = defaultdict(list)

    def replace_wildcard(matchobj):
        name = matchobj.group(0).strip("\\*")
        v = len(d_name[name])
        vname = name + str(v)
        d_name[name].append(vname)
        regexstr = r"(?P<" + vname + r">[^*]*)" # shortest match
        return regexstr

    regex_base = r"^" + re.escape(tpl) + r"$"
    tmp = REPLACER.sub(replace_wildcard, regex_base, count = 0)
    return re.compile(tmp)


def match_line(parsed_line, l_regex):
    for rid, regex in enumerate(l_regex):
        m = regex.match(parsed_line["message"])
        if m:
            return rid, m
    else:
        return None


if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        sys.exit("give me tpl filename and log filename")
    tpl_fp = sys.argv[1]
    data_fp = sys.argv[2]

    l_tpl = []
    l_regex = []
    with open(tpl_fp, 'r') as f:
        for line in f:
            tpl = line.rstrip()
            l_tpl.append(tpl)
            l_regex.append(generate_regex(tpl))

    import log2seq
    p = log2seq.init_parser()
    d_cnt = defaultdict(int)
    with open(data_fp, 'r') as f:
        for line in f:
            parsed_line = p.process_line(line)
            ret = match_line(parsed_line, l_regex)
            if ret is None:
                pass
            else:
                rid, mo = ret
                d_cnt[rid] += 1

    print("matched lines: {0}".format(sum(d_cnt.values())))
    for rid, cnt in d_cnt.items():
        print("{0},{1},{2}".format(rid, cnt, l_regex[rid]))
    for rid, tpl in enumerate(l_tpl):
        if rid in d_cnt:
            pass
        else:
            print("No match tpl: {0}, {1}".format(rid, tpl, l_regex[rid]))

